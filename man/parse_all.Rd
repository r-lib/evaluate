% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse.R
\name{parse_all}
\alias{parse_all}
\title{Parse, retaining comments}
\usage{
parse_all(x, filename = NULL, allow_error = FALSE)
}
\arguments{
\item{x}{object to parse.  Can be a string, a file connection, or a function.
If a connection, will be opened and closed only if it was closed initially.}

\item{filename}{string overriding the file name}

\item{allow_error}{whether to allow syntax errors in \code{x}}
}
\value{
A data frame with columns \code{src}, a character vector of source code, and
\code{expr}, a list-column of parsed expressions. There will be one row for each
top-level expression in \code{x}. A top-level expression is a complete expression
which would trigger execution if typed at the console.

The trailing \verb{\\n} at the end of each \code{src} is implicit.

The \code{expression} object in \code{expr} can be of any length: it will be 0 if
the top-level expression contains only whitespace and/or comments; 1 if
the top-level expression is a single scalar (like \code{TRUE}, \code{1}, or \code{"x"}),
name, or call; or 2 if the top-level expression uses \verb{;} to put multiple
expressions on one line.

If there are syntax errors in \code{x} and \code{allow_error = TRUE}, the data
frame will have an attribute \code{PARSE_ERROR} that stores the error object.
}
\description{
Works very similarly to parse, but also keeps original formatting and
comments.
}
\examples{
source <- "
  # a comment
  x
  x;y
"
parsed <- parse_all(source)
lengths(parsed$expr)
str(parsed$expr)

}
